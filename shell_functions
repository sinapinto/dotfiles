#!/bin/bash

# for testing wm
xep() {
    [ `pgrep Xephyr` ] && exit 1
    geom=680x600
    while getopts ":fh" opt; do
        case $opt in
            f) geom=1366x768;;
            h) echo "Usage: $0 [-f|-h] [window manager]"
                return 0 ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    Xephyr -ac -br -noreset -screen "$geom" :1.0 &
    sleep 0.5
    [ -n "$1" ] && wm=$1 || wm=tfwm
    DISPLAY=:1.0 $wm
}

# Escape potential tarbombs
etb() {
  l=$(tar tf $1);
  if [ $(echo "$l" | wc -l) -eq $(echo "$l" | grep $(echo "$l" | head -n1) | wc -l) ];
  then tar xf $1;
  else mkdir ${1%.t(ar.gz||ar.bz2||gz||bz||ar)} && tar xvf $1 -C ${1%.t(ar.gz||ar.bz2||gz||bz||ar)};
  fi ;
}

# create a new script, automatically populating the shebang line, editing the
# script, and making it executable.
shebang() {
  if i=$(which $1);
  then
    printf '#!/usr/bin/env %s\n\n' $1 > $2 && chmod 755 $2 && vim + $2 && chmod 755 $2;
  else
    echo "'which' could not find $1, is it in your \$PATH?";
  fi;
  # in case the new script is in path, this throw out the command hash table and
  # start over  (man zshbuiltins)
  rehash
}

xd() { xrdb -load ~/.Xresources }

lf() {
   if [ $# -gt 0 ]; then
      ls -t $1 | head -n6
   else
      ls -t  | head -n6
   fi
}

# node(){
#     [ -e .env ] && env $(cat .env) /usr/bin/node "$@" || /usr/bin/node "$@"
# }

largepkgs() { pacman -Qi | awk '/^Name/ {pkg=$3} /Size/ {print $4$5,pkg}' | grep MiB | sort -n }
t(){ env TERM=screen-256color-it tmux attach || env TERM=screen-256color-it tmux new }
mu () { mupdf "$@" &>/dev/null & disown }
m() {
    [ -z $1 ] && return 1
    if [ $1 = '-s' ]; then
        /usr/bin/mpv --fs --shuffle "$2" &>/dev/null & disown
    else
        /usr/bin/mpv --fs "$1" &>/dev/null & disown
    fi
}

rec() {
    ffmpeg -f x11grab -s 1366x768 -an -r 16 -loglevel quiet -i :0.0 -b:v 5M -y "$@"
}

cd() {
    if [ -n "$1" ]; then
        [ -d "$1" ] && { builtin cd "$1"; ls; } || builtin cd "$(dirname "$1")"
    else
        cd ~
    fi
}

cpf() {
   cp "$@" && cd "$_";
}

mvf() {
   mv "$@" && cd "$_";
}

mkf() {
   mkdir -p "$@" && cd "$_";
}

d(){
    case $1 in
        i) dtach -A /tmp/irssi.dtach irssi ;;
        w) dtach -A /tmp/weechat.dtach weechat ;;
        r) dtach -A /tmp/rtorrent.dtach rtorrent ;;
        z) dtach -A /tmp/zsh.dtach zsh ;;
        e) dtach -A /tmp/emacs.dtach emacs -nw ;;
        *) dtach -A /tmp/$1.dtach $1 ;;
    esac
}

touchpad(){
    local deviceid=$(xinput | grep TouchPad | cut -d "=" -f2| cut -f1)
    [ -z $deviceid ] && return 1
    val=$(xinput list-props $deviceid | grep able | tail -c 2)
    [ $val -eq 1 ] && xinput --disable $deviceid \
                   || xinput --enable $deviceid
}

# asdf(){
#     local file="$HOME/.playlist"
#     [ -f $file ] || return 1
#     [ -f "${file}.tmp" ] && rm -f "${file}.tmp" || echo "no temp file found"
#     shuf -n $(wc -l $file | cut -d " " -f1) $file > "${file}.tmp"
#     mpv --playlist="${file}.tmp"
# }

swap(){
    mv $1 tmp.$1
    mv $2 $1
    mv tmp.$1 $2
}

extract () {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2) tar xvjf $1;;
            *.tar.gz) tar xvzf $1;;
            *.bz2) bunzip2 $1;;
            *.gz) gunzip $1;;
            *.tar) tar xvf $1;;
            *.tbz2) tar xvjf $1;;
            *.tgz) tar xvzf $1;;
            *.zip) unzip $1;;
            *.Z) uncompress $1;;
            *) echo "'$1' cannot be extracted via >extract<" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

soneeded() {
   readelf -d $1 | awk '/NEEDED/ {gsub(/[\[\]]/, "", $5); print $5}'
}

elfcompress() {
   [[ -n "$@" ]] || {
      echo "usage : elfcompress [binary]"
      return
   }

   cp "$@" /tmp/compress.temp
   strip -s -R .comment -R .gnu.version /tmp/compress.temp

   gzip -c /tmp/compress.temp > /tmp/compress.gz
   echo 'a=/tmp/I;tail -n+2 $0|zcat>$a;chmod +x $a;$a;rm $a;exit' >> /tmp/unpack.header

   cat /tmp/unpack.header /tmp/compress.gz > "$@.packed"
   chmod +x "$@.packed"

   rm /tmp/compress.temp
   rm /tmp/compress.gz
   rm /tmp/unpack.header
}

calc() { noglob echo $(( $* )) }
